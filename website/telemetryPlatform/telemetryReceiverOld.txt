import socket, json, threading, time
from concurrent.futures import ThreadPoolExecutor, thread

class gameInstance:
    def __init__(self, payload):
        print("A game is being created")
        self.currentState = {}
        self.gameHistory = {}
        self.currentState["game"] = payload[0]
        self.lastInteraction = time.perf_counter()
        if int(payload[1]) == 0:
            self.player1 = "AI"
            self.player2 = "FOE"
        else:
            self.player1 = "FOE"
            self.player2 = "AI"

        self.currentState["move"] = payload[2]
        self.currentState["duration"] = payload[3]
    
    def __update__(self, payload):
        print("A game is being updated")
        rounds = len(self.gameHistory)
        self.gameHistory[rounds + 1] = self.currentState
        self.lastInteraction = time.perf_counter()
        self.currentState["game"] = payload[0]
        self.currentState["move"] = payload[2]
        self.currentState["duration"] = payload[3]
    
    def __export__(self):
        print("A game is being exported ")
        convertedGame = {}
        convertedGame["currentState"] = self.currentState
        convertedGame["gameHistory"] = self.gameHistory
        convertedGame["player1"] = self.player1
        convertedGame["player2"] = self.player2

        with open("json/activeGame.json", "w") as activeGameFile:
            json.dump(convertedGame, activeGameFile)        

def initServer():
    #serverAdress = "192.168.1.55"
    #serverAdress = "172.20.10.2"
    serverAdress = "192.168.0.40"
    serverPort = 5555

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    return server, serverAdress, serverPort

def threaded_client(conn):
    reply = ""
    conn.send(str.encode("Connected"))
    while True:
        try:
            data = conn.recv(2048)
            reply = data.decode("utf-8")
            payload = json.loads(reply)
            if not data:
                print("Disconnected")
                break
            else:
                print("Received", payload)
                print("Sending", "Payload Received")
            conn.sendall(str.encode("Payload Received"))
        except:
            break
    print("Lost connection")
    conn.close()
    return payload

def checkState(game):
    player1 = sum(game[1:7]) / 6
    player2 = sum(game[8:14]) / 6
    player1Score = game[7]
    player2Score = game[14]
    if (player1Score == 0 and player2Score == 1) or (player1Score == 1 and player2Score == 0):
        if 3 < player1 < 5 and 3 < player2 < 5:
            return True
    return False


def gameManager(pack):
    pack = list(pack)
    activeGames = pack[0]
    payload = pack[1]
    if len(activeGames) == 0:
        print("Creating Game")
        newGame = gameInstance(payload)
        print("New Game : ")
        print(newGame)
        activeGames.append(newGame)
        print("Manager active games : " + str(activeGames))
    else:
        print("Updating Game")
        activeGames[0].__update__(payload)
    print("Exporting Game")
    activeGames[0].__export__()
    return "Done"

def application():
    #payload = environ.get("QUERY_STRING")
    server, serverAdress, serverPort = initServer()
    try:
        server.bind((serverAdress, serverPort))
    except socket.error as e:
        print(str(e))

    server.listen(1)
    print("Waiting for connection")  

    activeGames = []

    while True:
        clientConnection, clientAdress = server.accept()
        print("Connected to : ", clientAdress)
        with ThreadPoolExecutor() as executor:
            client = executor.submit(threaded_client, clientConnection)
            payload = client.result()
        with ThreadPoolExecutor() as executor:
                if activeGames:
                    if time.perf_counter() - activeGames[0].lastInteraction > 300:
                        activeGames = []
                manager = executor.submit(gameManager, (activeGames, payload))
        print("Active Games : " + str(activeGames))
                
        

application()